body file control
{
        namespace => "northerntech_security_hardening";
}
bundle agent cve_2021_44228_log4j_inventory_log4shell
{
  vars:
    !windows::
      # The list of paths to search, overrideable via augments northerntech_security_hardening:cve_2021_44228_log4j_inventory_log4shell.scan_paths
      "scan_paths"
        slist => { "/opt", "/usr" },
        unless => isvariable( "$(this.namespace):$(this.bundle).$(this.promiser)" );

      "rescan_frequency_min"
        string => "1440",
        unless => isvariable( "$(this.namespace):$(this.bundle).$(this.promiser)" );

      "_cached_scan_log" string => "$(sys.statedir)/yahoo-check-log4j.sh.log";
      "_scanner" string => "$(sys.bindir)/yahoo-check-log4j.sh";
      "_scanner_wrapper" string => "$(sys.bindir)/run-yahoo-check-log4j.sh";

      # Wrap the paths in single quotes in case of spaces
      "_paths"
        slist => maplist( "'$(this)'", scan_paths );

      # Join the scan paths together with -p option so they can all be searched in a single execution
      "_path_scan_option"
        string => join( " -p ", _paths );

      # Simply fetching the raw source is the most simple way to accomplish this and it can be done without relying on external utilities
      "_scanner_src_url"
        string => "https://raw.githubusercontent.com/yahoo/check-log4j/master/src/check-log4j.sh";

      # We don't want to truncate the script, get up to 1MB
      "_url_get_options"
        data => '{ "url.max_content": "1000000" }';
      "_r" data => url_get( $(_scanner_src_url), _url_get_options );

      # Hey, we are pulling in some script from the internet, let's make sure we
      # are only running something we expect. So, these are sha512 sums
      # calculated after url_get() and rendering the file with the content
      # attribute
      "_known_sha512_hashes"
        slist => {
                   # https://github.com/yahoo/check-log4j/blob/36b9ab92a40663fb1bd8e9bd8ba8abf6a7e59bb1/src/check-log4j.sh
                   "642616cf18c90db1f9dd753a58a45fd5f984eb232de4663b26e9f4a87a85af86d43eed8daff0dbcb1cbcd22d3766e3cf64204c7be96b2d11e95fd941a08abc5b",
        };


      # To facilitate tracking remediation, we have this list of shas that are
      # OK for a potentially vulnerable file, add the sha to the list, make the
      # potentially vulnerable file disappear from inventory

      "files_sha512_ok"
        slist => { },
        unless => isvariable( "$(this.namespace):$(this.bundle).$(this.promiser)" );


      # We read the list of potentially vulnerable files in
      "_potentially_vulnerable_files"
        slist => readstringlist( "$(_cached_scan_log)", "", "\n", inf, inf),
        if => fileexists( "$(_cached_scan_log)" );

      # Because of limitations in reporting, we inventory individual variables
      # for each path with the same attribute name

      "potentially_vulnerable[$(_potentially_vulnerable_files)]"
        string => "$(_potentially_vulnerable_files)",
        meta => { "inventory", "attribute_name=Log4Shell Potentially Vulnerable" },
        unless => some( file_hash( "$(_potentially_vulnerable_files)", "sha512" ),
                    @(files_sha512_ok) );


      "positive_result"
        string => "yahoo-check-log4j.sh did not detect any potentially vulnerable files in $(with)",
        meta => { "inventory", "attribute_name=Log4Shell Potentially Vulnerable" },
        with => join( ", ", _paths ),
        if => and( fileexists( "$(_cached_scan_log)" ),
                   strcmp( length( getindices( potentially_vulnerable ), "0" ) ) );

  files:
    !windows::
      # Render the url_get response to a file that we can check the file hash for
      "$(_scanner).tmp"
        content => "$(_r[content])",
        perms => default:mog( "600", "root", "root" );

      # only copy the file into place if we recognize the sha512 sum
      "$(_scanner)"
        copy_from => default:local_dcp( "$(_scanner).tmp" ),
        perms => default:mog( "700", "root", "root" ),
        if => some( file_hash( "$(_scanner).tmp", "sha512" ),
                    @(_known_sha512_hashes) );

      # Render a wrapper for running the scanner. Not currently able to define
      # variables in a specific namespace via the module protocol, so we cache
      # the data and deal with tagging for inventory after reading the data into
      # policy.
      "$(_scanner_wrapper)"
        content => `
lockfile=/var/tmp/run-yahoo-check-log4j.sh
if ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null; then
  trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT
  > "$(_cached_scan_log).tmp"
  "$(_scanner)" -p $(_path_scan_option) >> "$(_cached_scan_log).tmp"
  awk '/Possibly vulnerable archive/ {print $(NF)}' "$(_cached_scan_log).tmp" \
  | tr -d "'"     \
  | sed s/.$//    \
  | sed s,/\./,/, \
  | sort -u > "$(_cached_scan_log)"
  # clean up after ourselves, and release the trap
  rm -f "$lockfile"
  trap - INT TERM EXIT
else
  echo "Lock Exists: $lockfile for pid $(cat $lockfile)"
fi
`;

      # Enforce permissions of scanner wrapper, not applied in timely way when
      # combined with content attribute so made as separate promise
      "$(_scanner_wrapper)"
        perms => default:mog( "700", "root", "root" );

      # Cull the log file every $(rescan_frequency_min), absence of log results in scan execution
      "$(_cached_scan_log)"
        delete => default:tidy,
        action => default:if_elapsed("$(rescan_frequency_min)");

  packages:
    !windows::
      # We need unzip in order to inspect bundled files
      "unzip"
        policy => "present";

  methods:
    !windows::
     "Daemonized check-log4j for on $(_paths)"
        usebundle => default:daemonize( "$(_scanner_wrapper)" ),
        unless => fileexists( "$(_cached_scan_log)" );
}
